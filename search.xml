<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于hexo站内搜索失败的解决方法]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%85%B3%E4%BA%8Ehexo%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[搭建站内搜索在搭建hexo的过程中，想实现站内搜索的功能，从官网找到如下步骤： 出现问题v跟着上面步骤做完，发现点击搜索按钮，页面就一直处于loading的状态。 通过查阅资料后得知，是由于我们的文章markdown文件中，出现了一些奇怪的ASCII码，比如表示退格键的BS：可以看到，代码中出现了一个很小的BS，通过光标在文章中移动，可以很明显地感觉到光标在该字符处需要移动两次，但单从外观上几乎难以看出来，因为编辑器显示的时候不会将其显示出来： 这个就是导致我们站内搜索一直失败的罪魁祸首。 解决问题那么如何解决这个问题呢？ 手动删除在每一篇文章中，通过替换的方法将其替换为空。 Remove backspace control character使用插件 Remove backspace control character 安装好该插件后，通过 Format Document（Mac中通过Command + Shift + P 唤起，然后输入Format Document）的命令将文章中的异常字符去除，再保存 这样就可以正常使用站内搜索啦~！参考: vscode控制字符引起的问题以及解决思路 | 作者：Dk]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2018%2F07%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[TCP和UDP协议区别TCP:是面向连接的协议,在收发数据前，必须和对方建立可靠的连接,是可靠的字节流，TCP协议（传输控制协议）提供可靠的端到端的通信，可以保证接收方收到的数据与发送方发送的数据完全一致，能够保证数据不丢失、无差错，同时还有流量控制和拥塞控制的功能，用于传输大量数据，首部最少20字节，TCP的可靠性是通过顺序编号和确认（ACK）来实现的。当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 UDP:是无连接的协议，不需要建立连接，不可靠的，面向数据报的，没有重传和拥塞控制其开销远小于TCP协议，UDP协议不能保证数据不丢失、无差错，也不能保证接收方收到数据的顺序和发送方发送数据的顺序一样。UDP协议比较简单，适用于传输少量数据，首部开销小，只有8字节当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TCP协议的特点（1）面向连接的（2）提供可靠的数据传输服务（3）提供流量控制。TCP能够控制进程发送数据的速率，保证另一端不被大量的数据“淹没”而出现溢出。（4）提供拥塞控制。当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。（5）提供全双工通信。TCP提供双向的数据传输服务。TCP允许通信双方的应用进程在任何时候发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。（6）TCP是面向字节流的。TCP中的“流”是指流入到进程或从进程流出的字节序列。 UDP协议的特点（1）无连接的。（2）UDP是一种尽力而为的服务方式，不提供可靠的数据传输服务（比如数据的丢失、重复和无序）。（3）UDP是高效的传输协议。（4）UDP没有拥塞控制和流量控制。 物理层（集线器中继器（Repeater，也叫放大器），集线器）、数据链路层（交换机网桥，交换机）、网络层（路由器，ip）、运输层(会话层、表示层)、应用层。TCP/IP五层模型的协议应用层传输层：四层交换机、也有工作在四层的路由器网络层：路由器、三层交换机数据链路层：网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层） 物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层 网络层：IP协议、ICMP协议、ARP协议、RARP协议。 传输层：UDP协议、TCP协议。 应用层：FTP（文件传送协议）、Telenet（远程登录协议）、DNS（域名解析协议）（UDP,其他都是TCP）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议。SNMP也是udp，DHCP也是udp 子网掩码子网掩码和网络号相与得到的是本网络的网络号，剩下的部分确定主机号。所以分配主机个数的时候，比原来的多出来的1的个数就决定主机个数子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。用于子网掩码的位数决定于可能的子网数目和每个子网的主机数目 HTTP协议的主要特点 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST，PUT,DELETE,OPTION。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP中，POST与GET的区别(1)Get是从服务器上获取数据，Post是向服务器传送数据。(2)Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。(3)Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。 浏览器请求过程 client浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到client到server的路径。client浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 在client的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如server使用80端口监听client的请求，客户端由系统随机选择一个端口如5000，与server进行交换，server把相应的请求返回给client的5000端口。然后使用IP层的IP地址查找目的端。 client的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达server，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达server。 client的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达server的地址。 1，这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器 TCP：三次握手和四次挥手最初都是closed状态，B先进入监听listen三次握手过程，为什么需要三次而不是两次？1，A向B发出连接请求报文，这时SYN=1,seq=x,消耗一个序列号，a进入SYN-SEND,同步已发送状态2，如果B同意建立连接，则发送确认报文，SYN=1,ACK=1,seq=y,ack=x+1,b进入同步接收（syn-rcvd） 状态3，A收到B的确认后，还要给B进行确认，确认ACK=1，ack=y+1,seq=x+1,连接建立,a，b进入established 为什么需要三次不是两次？假如是两次，防止已经失效的报文再次到B,有这样一种情况，A向B发送链接请求，但是中途因网络原因滞留，这时A发送请求和B建立连接，确认，数据传输完成，但是这时第一条到了，B请求建立连接，但这时是不需要的。假如三次的话，A没有发出确认，B就认为这时不需要的。 四次挥手过程1，A向B发出链接释放报文，FIN=1，seq=u，a进入FIN-Wait（终止等待状态）2，B收到连接释放报文后发出确认，确认号ACK=1，ack=u+1,seq=v，b进入CLosed-Wait关闭等待状态，此时a-b链接释放，半关闭，a进入FIN-wait23，B向A发出连接释放报文FIN=1，ACK=1，seq=w，ack=u+1,b进入last-ack4，A收到连接释放报文后，发出确认，ACK=1，ack=w+1，seq=u+1,a进入time-wait状态，等待2MSLa进入clostd]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[进程和线程进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。进程是系统中的并发执行的单位线程是进程的一个实体，是CPU调度和分派的基本单位，也是程序执行的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。 多线程还是多进程？进程创建销毁比较耗费资源，线程则不然。进程切换也耗费资源，而线程只需保存少量变量进程CPU利用率低什么时候单进程比单线程好，相关性弱的单进程，相关性强的多线程 进程编程简单，线程编程复杂 需要频繁创建销毁的优先用线程这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的需要进行大量计算的优先使用线程所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是图像处理、算法处理。强相关的处理用线程，弱相关的处理用进程 （1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。（3）处理机分给线程，即真正在处理机上运行的是线程。（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 （1）调度： 在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程编程轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用，但是在由一个进程中的线程切换到另一进程中的线程，依然会引起进程切换。（2）并发性： 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而更有效地提高系统资源和系统的吞吐量。例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。（3）拥有资源： 不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，他可以拥有自己的资源。一般地说，线程自己不能拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一个进程的其他所有线程共享。（4）独立性： 在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是因为为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。（5）系统开销： 由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。类似的，在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现也变得比较容易。在有的系统中，现成的切换、同步、和通信都无需操作系统内核的干预。 一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高进程在执行的过程中有独立的内存单元，而多个线程共享内存，从而极大地提升了程序的运行效率 线程同步的方式有哪些？互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。临界区：在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开，类似于互斥量 说一说进程同步有哪几种机制。原子操作、信号量机制、自旋锁管程、会合、分布式系统 管道、系统IPC（包括消息队列、信号量、共享存储）、SOCKET 用户态切换到内核态的3种方式：系统调用、异常、外围设备中断。 各种调度汇总作业调度算法： FCFS先来先服务有利于长作业，不利于短作业。 短作业优先也就是只考虑运行时间。优点是短作业得到了优先执行，提高了系统的效率。缺点是当作业不断进入时，长的作业有可能长时间排不上队 最高响应比优先算法(HRN)：FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。 基于优先数调度算法(HPF)：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。 进程调度算法： 先进先出算法(FIFO)：按照进程进入就绪队列的先后次序来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。 时间片轮转算法(RR)：分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。 最高优先级算法(HPF)：进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。分为抢占式和非抢占式 多级队列反馈法：几种调度算法的结合形式多级队列方式。 空闲分区分配算法： 首先适应算法：当接到内存申请时，查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配。此算法简单，可以快速做出分配决定。 最佳适应算法：当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。 最坏适应算法：当接到内存申请时，查找分区说明表，找到能满足申请要求的最大的空闲区。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。 磁盘调度： 先来先服务（FCFS）：是按请求访问者的先后次序启动磁盘驱动器，而不考虑它们要访问的物理位置 最短寻道时间优先（SSTF）：让离当前磁道最近的请求访问者启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题 扫描算法（SCAN）或电梯调度算法：总是从磁臂当前位置开始，沿磁臂的移动方向去选择离当前磁臂最近的那个柱面的访问者。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。 循环扫描算法（CSCAN）：循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。 虚拟页式存储管理中的页面置换算法： 先进先出页面置换算法(FIFO)：选择最先进入内存的页面予以淘汰。 最近最久未使用算法（LRU）：选择在最近一段时间内最久没有使用过的页，把它淘汰。 最少使用算法（LFU）：选择到当前时间为止被访问次数最少的页转换。 产生死锁的四个必要条件：（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 死锁避免算法：银行家算法分页与分段的主要区别1）、段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。2）、页的大小固定不变，由系统决定。段的大小是不固定的，它由其完成的功能决定。3）、段式向用户提供的是二维地址空间，页式向用户提供的是一维地址空间，其页号和页内偏移是机器硬件的功能。4）、由于段是信息的逻辑单位，因此便于存贮保护和信息的共享，页的保护和共享受到限制。分页与分段存储管理系统虽然在很多地方相似，但从概念上讲，两者是完全不同的，它们之间的区别如下： ①页是信息的物理单位。分页的目的是实现离散分配，减少外部碎片，提高内存利用率。段是信息的逻辑单位。每一段在逻辑上是一组相对完整的信息集合。 ②分页式存储管理的作业地址空间是一维的，而分段式存储管理的作业地址空间是二维的。 ③页的大小固定且由系统确定，是等长的。而段的长度不定。 ④分页的优点体现在内存空间的管理上，而分段的优点体现在地址空间的管理上。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据类型笔记]]></title>
    <url>%2F2018%2F07%2F19%2FJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据类型概要5种基本数据类型：Undefined,Null,Boolean,Number,String1种复杂数据类型：Objecttypeof 返回值：undefined, boolean, string, number, function, object。null返回object，正则返回function, 因为Null其实是一个空对象指针 基本数据类型Number 八进制第一位必须是0，如果超出范围，第一位0无效，当做十进制。十六进制 0x。进行计算时，都转换成十进制。 对浮点数：如果小数点后没有带数字，或者本身就是一个整数，都会转换成整数。 科学计数法 3e-10 等于 3x10^(-10)。 浮点数做运算，注意精确度。比如 0.1+0.2不等于0.3 无穷 Infinity -Infinity Number.MAX_VALUE Number.MIN_VALUE NaN 任何涉及NaN的操作都会返回NaN，NaN与任何值不相等包括NaN本身。 String字符串一旦创建，不能改变值。每次都销毁原来的字符串再重新填充新的。 Object可以通过new创建，new 如果不给构造函数传参数，可以省略括号Object;```123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960* Object属性 * constructor 构造函数，保存用于创建当前对象的函数 * hasOwnProperty(propertyName) 检查属性在不在当前对象实例中（不是实例的原型） * isPrototypeOf(object) 检查传入对象是否是当前对象的原型 * propertyIsEnumberable(propertyName) 检查给定属性能否用for-in语句枚举 * toLocalString(), toString() 返回对象的字符串表示 * valueOf() 返回对象的字符串、数值或者布尔值表示，通常与toString相同# 引用类型## Object创建方式 1.new Object() 2.对象字面量访问属性 1.点表示法 .xxx 2.方括号表示法 [‘xxx’]## Array创建方式 1.new Array() 2.数组字面量可以通过length属性 移除数组的项 或者添加新项sort()方法比较的是字符串，会调用每项的toString，所以要比较数值的话，传入比较函数indexOf() lastIndexOf() 接受2参数，要查找的项和查找起点。一个从头开始找，一个从尾开始。查找使用的是全等操作符迭代 every() filter() forEach() map() some() 接受2参数 要运行的函数，运行该函数的作用域对象-影响this值 运行的函数接受3参数 数组项的值，位置，数组对象本身every() 函数对每一项都返回true的话，返回truesome() 函数对任一项有返回true的话，返回truefilter() 返回数组，数组由函数得true的项组成map() 返回所有函数结果组成的数组forEach()无返回，所有项运行函数归并 reduce() reduceRight() 迭代所有项，构建一个最终返回的值。reduceRight()就是从数组尾开始遍历数组接受2参数 要运行的函数，归并基础的初始值函数接受4参数 前一个值，当前值，项的索引，数组对象。函数返回的任何值都会作为第一个参数自动传给下一项## Date创建方式 new Date() 默认当前时间，如果要指定时间，new Date(Date.parse())或new Date(Date.UTC())。也可以直接加，相当于默认使用parse()Date.parse() 接受一个表示日期的字符串参数，返回相应日期的毫秒数。Date.UTC() 接受参数分别是年，月(0-11)，日，小时，分钟，秒，毫秒。年月必须有，日默认1，其他默认0。Date.now() 返回调用时的日期和时间的毫秒数。toDateString() 显示星期几 月 日 年toTimeString() 显示时 分 秒 时区toUTCString() 显示完整格式的UTC日期## 正则RegExpPerl语法 /pattern/flags flags: g全局， i不区分大小写，m多行模式 元字符：() [] &#123;&#125; \ ^ $ | ? * + . 使用元字符需要转义RegExp构造函数 接受2参数，匹配的字符串模式pattern，可选的flags.global 布尔值 是否设置了g标志 .ignoreCase 布尔值 是否设置了i标志 .lastIndex 整数，开始搜索下一个匹配项的字符位置，从0算起.multiline 布尔值 是否设置了m标志 .source 正则表达式的字符串表示方法 .exec() .test().exec() 接受1参数 要应用模式的字符串，返回包含第一个匹配项信息的数组，没有匹配项返回null。返回的数组包含属性index，input。 index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串数组中 第一项是整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串即使设置全局g标志，exec每次也只返回一个匹配项。不设置的话永远返回第一个匹配项，设置的话每次都从上次匹配位置后开始。.test() 接受1参数 字符串。模式与该参数匹配的话返回true，否则false。.toString 返回正则表达式的字面量属性 input $_ 最近一次要匹配的字符串lastMatch $&amp; 最近一次的匹配项lastParen $+ 最近一次匹配的捕获组leftContext $input字符串中lastMatch之前的文本 rightContext $’ input字符串中lastMatch之后的文本 multiline $* 布尔值，是否所有表达式都使用多行模式 `` 函数 没有重载创建 1.函数声明语法 function f(){…} 2.函数表达式 var f = function(){…}; 3.使用Function构造函数（这也是一种函数表达式，但不推荐）（注意函数表达式要加分号，就像声明其他变量一样） 函数声明与函数表达式的区别 解析器会率先读取函数声明，并使其在执行任何代码前可用 函数表达式必须等到解析器执行到它所在的代码行，才会真正被解释执行。 判断类型 typeof x判断x的类型 string number boolean undefined object x instanceof constructor判断x是不是类型constructor isFinite(x)是不是有穷的 isNaN(x)任何不能被转换成数值的值 返回true先把值转换成数值，如果是对象 调用valueOf()，再调用toString() Array.isArray(x)判断是否是数组 转换类型 Boolean(x) true,false Number 非零数字(包括无穷大), 0和NaN Undefined N/A, undefined String 非空字符串, “” Object 任何对象，null Number(x) 1,0 Booleantrue,false null 0 undefined NaN String如果只含数字或者有效的浮点格式，转成对应的数值。（忽略前导0）；如果包含有效的十六进制格式 0x 转成对应的十进制；如果是空的，转成0如果不是上述情况，转成NaN parseInt(x, 10)，parseFloat(x) 用于转 string 为 number，后面是进制，parseFloat只解析十进制忽略字符串前的空格，从第一个非空格开始，第一个字符不是数字或负号，返回NaN。直到解析完所有后续字符 或者 遇到一个非数字字符。0开头 8进制，0x开头 16进制小数点 parseInt无效，parseFloat第二个小数点无效，parseFloat如果结果是整数，返回整数e.g. ’1234blue’-&gt;1234 ‘’-&gt;NaN String(x) 如果值有.toString方法，直接调用.toString()方法如果是null, undefined 返回”null” “undefined” .toString(10) 参数是进制 null 和 undefined 没有这种方法 valueOf() 返回对象的字符串、数值或者布尔值表示，通常与toString相同 数组方法push() 队尾加，返回长度pop() 队尾移除，返回移除掉的项shift() 队头移除，返回移除掉的项unshift() 队头加，返回长度reverse() 反转，返回排序后的数组sort() 排序，返回排序后的数组concat() 连接，创建新数组splice(p,n,r) p操作的位置，n删除的数量，r插入的项(任意数量)slice() 接受2参数，起始和结束。返回截取部分，不会影响原数组。reduce() 归并 详见Array部分reduceRight() 归并 详见Array部分 .every() 函数对每一项都返回true的话，返回true.some() 函数对任一项有返回true的话，返回true.filter() 返回数组，数组由函数得true的项组成.map() 返回所有函数结果组成的数组.forEach() 无返回，所有项运行函数]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型链学习笔记]]></title>
    <url>%2F2018%2F07%2F19%2FJS%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[先上结论123456789person1.__proto__ == Person.prototypePerson.__proto__ === Function.prototypeObject.__proto__ === Function.prototypeFunction.__proto__ === Function.prototypePerson.prototype.__proto__ == Object.prototypeFunction.prototype.__proto__ == Object.prototypeObject.prototype.__proto__ == null 结论 一. 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。 二. person1 和 person2 都是 构造函数 Person 的实例一个公式：实例的构造函数属性（constructor）指向构造函数。 三. 每个对象都有 proto 属性，但只有函数对象才有 prototype 属性。（普通对象的proto 指向它的构造函数的prototype； 函数对象的proto全都指向 Function.prototype）原型对象（Person.prototype）是 构造函数（Person）的一个实例。PS: Function.prototype 它是函数对象，但它很特殊，他没有prototype属性 console.log( typeof Function.prototype.prototype ) //undefined Function.prototype 为什么是函数对象呢？ var A = new Function (); Function.prototype = A; 四. JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做proto 的内置属性，用于指向创建它的构造函数的原型对象。person1.proto == Person.prototype这个连接存在于实例（person1）与构造函数（Person）的原型对象（Person.prototype）之间，而不是存在于实例（person1）与构造函数（Person）之间。 五. 六. 七. 所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bindFunction.prototype.proto === Object.prototypeObject.prototype.proto === null // true 八. 所有函数对象的 proto 都指向 Function.prototype，它是一个空函数（Empty function）Object 的每个实例都具有以上的属性和方法。所以我可以用 Person.constructor 也可以用 Person.hasOwnProperty。Object.getOwnPropertyNames 获取所有（包括不可枚举的属性）的属性名不包括 prototy 中的属性，返回一个数组 九. 给Person.prototype赋值的是一个对象直接量{getName: function(){}}，使用对象直接量方式定义的对象其构造器（constructor）指向的是根构造器Object，Object.prototype是一个空对象{}，{}自然与{getName: function(){}}不等。 十. Object.proto === Function.prototype // trueFunction.proto === Function.prototype // true Function.prototype.proto === Object.prototype //true 十一. 原型和原型链是JS实现继承的一种模型。 原型链的形成是真正是靠proto 而非prototype 在默认情况下，所有的原型对象都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数（Person） 一个普通对象的构造函数 === Object Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。 person1.proto 是什么？ Person.proto 是什么？ Person.prototype.proto 是什么？ Object.proto 是什么？ Object.prototype__proto__ http://www.jianshu.com/p/652991a671861234567891011121314151617181920212223function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;); //以上均为函数对象var A = new Person();Person.prototype = A;Person.prototype.constructor == Person;person1 = new Person();person1.__proto__ == Person.prototype;person1.constructor == Person;Object.prototype.__proto__ === null//所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身（Array String Number Boolean Error Date RegExp）Object.__proto__ === Function.prototype // trueObject.constructor == Function // trueFunction.__proto__ === Function.prototype // trueFunction.constructor == Function //trueFunction.prototype.__proto__ == Object.prototypeObject.prototype.__proto__ == null // 到顶了 对象的基本对象创建方法 new 对象字面量 year 属性前有下划线，是一种常用的记号，表示只能通过对象方法访问的属性 两对方括号 表示特性是内部值，不能直接访问它们。 有两种属性：数据属性 和 访问器属性| 数据属性 |||—|—|| [[Configurable]] | 默认true，表示能否通过delete删除，能否修改属性特性，能否把属性修改为访问器属性|| [[Enumerable]] | 默认true，表示能否通过for-in循环返回属性|| [[Writable]] | 默认true，表示能否修改属性的值|| [[Value]] | 包含这个属性的数据值| 访问器属性 [[Configurable]] [[Enumerable]] [[Get]] 默认undefined，在读取属性时调用的函数 [[Set]] 默认undefined，在写入属性时调用的函数 创建对象 工厂模式 构造函数模式构造函数始终以一个大写字母开头，而非构造函数以一个小写字母开头可以将自定义的构造函数的实例标识为一种新的特定类型，用 instanceof 检测。构造函数没有显式创建对象；直接将属性和方法赋给了this对象；没有return语句。 缺点：每个方法都要在实例上重新创建一遍。 解决：把方法的函数定义转移到构造函数外。 原型模式创建每个函数都有一个原型属性（prototype），是一个指针，指向一个原型对象。原型对象prototype 包含可以由特定类型的所有实例共享的属性和方法。原型对象会自动获得一个constructor（构造函数）属性，指向prototype属性所在函数的指针。通过这个constructor 可以继续给原型对象添加其他属性和方法。当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性）指向构造函数的原型对象。可以通过 __proto__属性访问。【实例中的指针指向原型，而不是构造函数！】这个连接是存在于实例与原型对象之间的，不是存在于实例与构造函数之间的。每次读取某个对象的某个属性时，先从实例对象开始，如果实例中有该属性，则返回该属性；没有则搜索它的原型对象。实例中的同名属性会屏蔽原型中的属性。使用delete可以删除实例属性，重新访问原型中的属性。如果原型对象使用对象字面量来重写，那么这个prototype的constructor属性，就不会再指向原型对象了，而是指向Object构造函数。所以需要重新让constructor 指向原型对象。但是以这种方式重设constructor属性，会使constructor属性的 [[Enumerable]] 特性变成true，（原生constructor属性是不可枚举的）所以可以使用 Object.defineProperty 的方法。对原型所做的修改都能立即反映在实例上。把原型修改为另外一个对象 就等于 切断了构造函数和最初原型的联系。变成了一个新的原型。所以实例也就被切断了和新的原型的联系。 优点: 使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。 缺点: 所有实例在默认情况下都将取得相同的属性值 最大问题 由其共享的本性导致。对于引用类型。 构造函数模式与原型模式组合 使用最广泛、认同度最高的一种创建自定义类型的方法。构造函数模式用于定义实例属性，原型模式用于定义方法和共享属性。 动态原型模式通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。Ps: 使用动态原型模式时，不能使用对象字面量重写原型，不然会切断现有实例和新原型之间的联系。 寄生构造函数模式模式和工厂模式一模一样，只是封装创建对象的代码，返回新创建的对象。 稳妥构造函数模式没有公共属性不引用this对象； 不使用new调用构造函数。 原型链确定原型和实例的关系123456instanceof instance instanceof Object //true instance instanceof SuperType //trueisPrototypeOf Object.prototype.isPrototypeOf(instance) //true SuperType.prototype.isPrototypeOf(instance) //true 通过原型链继承时， 重写原型链中已经存在的方法，会屏蔽原来的方法。 不能使用对象字面量创建原型的方法，这样会重写原型链。 问题： 通过原型实现继承时，原型实际上会变成另一个类型的实例。于是原先的实例属性也就变成了现在的原型属性。 创建子类型的实例时，不能向超类型的构造函数中传递参数。 所以有了以下 1. 借用构造函数（也叫 伪造对像 经典继承）在子类型构造函数的内部调用超类型构造函数。123function SubType() &#123; SuperType.call(this);&#125; 优点：可以向超类型构造函数传递参数缺点： 1 函数复用 2 在超类型的原型中定义的方法，对子类型而言是不可见的 2. 组合继承 （也叫 伪经典继承）将原型链和借用构造函数的技术组合起来。思路：使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。 3. 原型式继承不必创建自定义类型，本质上object() 对传入其中的对象执行了一次浅复制。12345function object(c) &#123; function F() &#123;&#125;; F.prototypr = o; return new F();&#125; 规范化 object.create() 接受2参数，用作新对象原型的对象，一个为新对象定义额外属性的对象（额外属性会覆盖原型对象上的同名属性） 4. 寄生式继承待补充 5. 寄生组合式继承通过原型链的混成形式来继承方法，通过借用构造函数来继承属性。背后的基本思路：不必为了指定子类型的原型而调用超类型的构造函数。本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 方法：1234567891011121314151617181920212223242526272829303132Object.defineProperty() 修改属性默认的特性， 接受3参数 属性所在的对象，属性的名字，一个描述符对象 如果没有指定描述符对象，则configurable enumerable writable的属性默认为false。如果有描述符则无此限制 可以多次调用defineProperty()，但是一旦设置 [[Configurable]]为false，就只能修改 writable的特性。Object.defineProperties() 定义多个属性特性。 接受2参数 1.属性所在的对象，2.第二个对象的属性与第一个对象中要添加或修改的属性一一对应。Object.getOwnPropertyDescriptor() 读取属性的特性 接受2参数 属性所在的对象， 要读取其描述符的属性名称 。 返回一个对象，如果是数据属性，有configurable enumerable writable value，如果是访问器属性，有configurable enumerable get set.isPrototypeOf( ) 判断是否是原型对象比如 alert( Person.prototype.isPrototypeOf( person1 ) ) //true.getPrototypeOf( ) 返回这个对象的原型比如 alert( Object.getPrototypeOf( person1 ) == Person.prototype ) //true delete 删除某个属性比如 delete person1.name.hasOwnProperty( ) 检测属性是否存在于实例比如 alert( person1.hasOwnProperty( &quot;name&quot; ) ) //falsein 能否通过对象访问给定属性，无论是在实例还是原型中比如 alert( &quot;name&quot; in person1 ) //trueObject.keys( ) 获得可枚举的实例属性比如 alert( Object.keys( Person.prototype ) ) //&quot;name&quot;,&quot;age&quot;,&quot;sayName&quot;Object.getOwnPropertyNames( ) 获得所有实例属性（包括不可枚举的） 比如 alert( Object.getOwnPropertyNames( Person.prototype ) ) //&quot;constructor&quot;,&quot;name&quot;,&quot;job&quot;,&quot;sayName&quot;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>JS原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 冒泡 n2 n n2bubbleSort(arr) &#123; for(let i=0; i&lt;arr.length; i++) &#123; for(let j=1; j&lt;arr.length-i; j++) &#123; if(arr[j-1] &gt; arr[j]) &#123; [arr[j-1], arr[j]] = [arr[j], arr[j-1]]; &#125; &#125; &#125;&#125;// 选择排序 每次选最小的 n2 n2 n2choiceSort(arr) &#123; for(let i=0; i&lt;arr.length; i++) &#123; let min = i; for(let j=i; j&lt;arr.length; j++) &#123; if(arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; [arr[i], arr[min]] = [arr[min], arr[i]]; &#125;&#125;// 插入排序 从后往前走 n2 n n2insertSort(arr) &#123; for(let i=0; i&lt;arr.length; i++) &#123; let index = i; const num = arr[i]; while (index&gt;0 &amp;&amp; arr[index-1] &gt; num) &#123; arr[index--] = arr[index-1]; &#125; arr[index] = num; &#125;&#125;// 快排 m是关键 nlogn nlogn n2quickSort(arr, low, high) &#123; if(low &gt; high) return; let m = low; for(let i=low+1; i&lt;=hign; i++) &#123; if(arr[i] &lt; arr[low]) &#123; m++; [arr[m], arr[i]] = [arr[i], arr[m]]; &#125; &#125; [arr[low], arr[m]] = [arr[low], arr[m]]; this.quickSort(arr, low, m-1); this.quickSort(arr, m+1, high);&#125; // 归并 nlogn mergeSort(arr, low, high) &#123; if(low &gt;= high) &#123; return; &#125; let mid = low + parseInt((high - low)/2); this.mergeSort(arr, low, mid); this.mergeSort(arr, mid+1, high); this.merge(arr, low, mid, high);&#125;merge(arr, low, mid, high) &#123; let help = []; help.length = arr.length; for(let k = low; k &lt;= high; k++) &#123; help[k] = arr[k]; &#125; let i = low, j = mid + 1; for(let k = low; k &lt;= high; k++) &#123; if(i &gt; mid) &#123; arr[k] = help[j++]; &#125;else if(j &gt; high) &#123; arr[k] = help[i++]; &#125;else if(help[i] &lt; help[j]) &#123; arr[k] = help[i++]; &#125;else &#123; arr[k] = help[j++]; &#125; &#125;&#125; 深拷贝1234567891011121314151617181920212223242526272829function deepClone(source) &#123; var target; if(source === null || typeof source != &apos;object&apos;) return source; if(source instanceof Date) &#123; target = new Date(); target.setTime(source.getTime()); return target; &#125; if(source instanceof Array) &#123; target = []; for(var i = 0; i &lt; source.length; i++) &#123; target[i] = deepClone(source[i]); &#125; return target; &#125; if(source instanceof Object) &#123; target = &#123;&#125;; for(var key in source) &#123; if(source.hasOwnProperty(key)) &#123; target[key] = deepClone(source[key]); &#125; &#125; return target; &#125;&#125; 数组去重给Array写一个方法unique完成去重复的功能12345678910111213 Array.prototype.uniq = function() &#123; var temp=&#123;&#125;,k=0; for(var i=0; i &lt; this.length; i++) &#123; if(temp[this[i]] == undefined)&#123; temp[this[i]]=1; this[k++]=this[i]; &#125; &#125; this.length=k; return this;&#125;var array= [1,&apos;a&apos;,1,&apos;a&apos;,&apos;kl&apos;,&quot;name&quot;,&quot;karl&quot;,&apos;kl&apos;];array.uniq() ES6写法1234567&apos;use strict&apos;;let arr = [1,&apos;a&apos;,undefined,null,NaN,1,&apos;a&apos;,undefined,null,NaN];Array.prototype.remDub = Array.prototype.remDub || function () &#123; //return Array.from(new Set(this)); return [...new Set(this)];&#125;;console.log(arr.remDub()); //[ 1, &apos;a&apos;, undefined, null, NaN ] 二叉树求和12345678function sumup(root, sum)&#123; sum += root.value; if(root.left)&#123; sumup(root.left); &#125;else if(root.right)&#123; sumup(root.right); &#125;&#125; 为es5的Array写forEach12345678910Array.prototype.forEach = function(cb)&#123; for(var i = 0;i&lt; this.length;i++)&#123; cb(this[i],i); &#125; return this;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web缓存机制]]></title>
    <url>%2F2018%2F07%2F19%2Fweb-cache%2F</url>
    <content type="text"><![CDATA[缓存前端主要的缓存方法有 Cache-Control, Expires, Last-modified, ETag, localStorage, sessionStorage 下面将依次介绍。 Cache-Controlmax-age（单位 s）指定设置缓存的最大有效时间，定义的是时间长短。浏览器向服务器发送请求后，在 max-age 时间里不会再向浏览器发送请求如图，缓存有效期为2592000秒（30天），即30天内都会使用这个版本的资源，即使服务器上的资源发生改变浏览器也不会得到通知，max-age会覆盖 Expires s-maxage（单位 s） 和max-age一样，但只用于共享缓存（比如CDN）如当s-maxage=60时，在这60秒中，即使CDN的内容更新，浏览器也不会请求。 max-age用于普通缓存，s-maxage用于代理缓存。 如果存在s-maxage，则会覆盖max-age和 Expires header public 指定响应会被缓存，在多用户间共享private 响应只作为私有缓存，不在用户间共享 （如果要求http认证，响应会自动设置为private） no-cache 指定不缓存响应，表明资源不尽兴缓存 设置 no-cache 不代表浏览器不缓存，而是在缓存前向服务器确认资源是否被更改，所以有时候只设置no-cache防止缓存是不保险的，还可以加上private指令，将过期时间设置为过去的时间。 no-store 绝对禁止缓存must-revalidate 指定如果页面过期就去服务器进行获取。 不常用 Expires （HTTP 1.1开始，使用Cache-Control：max-age替代）缓存过期时间指定资源到期的时间，是服务器端的具体的时间。Expires = max-age + 请求时间需要和 last-modified 结合使用cache-control 的优先级更高Expires 是服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存中获取数据，无需再次请求。 Last-modified服务器文件的最后修改时间，需要和 cache-control 结合使用，是检查服务器资源是否更新的一种方式。当浏览器再次请求时，会向服务器传送 If-Modified-Since 报头，询问 Last-Modified 时间点之后资源是否被修改过，如果没修改，返回304，使用缓存；如果修改过，再次向服务器请求资源，返回码和首次请求一样为200，资源为服务器端最新资源。 ETag根据实体内容生成一段hash字符串，标识资源状态，由服务器端产生。浏览器会将这串字符串传回服务器，验证资源是否已修改 ETag可以解决Last-modified存在的问题： 1、一些服务器不能精确得到资源的最后修改时间，这样就无法通过 last-modified 判断资源是否更新； 2、如果资源修改频繁，在秒以下的单位时间内进行修改，而 last-modified 只能精确到秒； 3、如果资源的 last-modified 改变了，但是资源内容没变，ETag就认为资源还没有修改。 LocalStorage 和 SessionStorageLocalStorage在PC上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用localStorage的速度比不上304。并且不能缓存css文件。而移动端由于网速慢，使用localStorage要快于304。 缓存流程 cache-control 流程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令（二）]]></title>
    <url>%2F2018%2F07%2F19%2Fgit%E5%91%BD%E4%BB%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[本地git commit 提交记录git log 查看记录git branch xxx 新建分支xxx git checkout xxx 切换到xxx分支 git checkout -b xxx 新建xxx并切换到这个分支 git branch -f master xxx 强制把master分支指向xxx git branch -d 删除分支git merge yyy 把yyy合并到当前分支git rebase xxx 取出提交记录，并“复制”它们，在另一个地方xxx逐个放下去，可以创造更线性的提交历史（原来的节点依然存在） git checkout C1 分离HEAD到C1 cart.git/HEAD查看HEAD指向，git symbolic-ref HEAD查看HEAD指向的引用git checkout HEAD^ ^父节点， ~n往上n个父节点 git reset HEAD~1 回退，同时撤销的节点在本地就不存在了。主要用于本地git revert HEAD 回退，在撤销的提交记录后面多了一个新提交。主要用于远程 git cherry-pick &lt;提交号&gt; 将一些提交复制到当前所在的位置（HEAD）git cherry-pick C2 C4 注意 cherry-pick 不能取上游的节点 git rebase -i 交互式rebasegit rebase -i HEAD~4 git tag git tag v1 C1 让标签v1指向提交记录C1，如果v不指定提交记录，则以HEAD所指向的位置git describe 可以是任何能被git识别成提交记录的引用，如果没有指定的话 就是HEAD 输出结果 __g tag表示离ref最近的标签，numCommits表示 ref和tag相差多少提交记录，hash表示ref的哈希值前几位 若ref提交记录上有某个标签时，只输出标签名称 git bisect 查找产生BUG的提交记录的指令 远程origin/master origin即远程分支名字，master为本地分支。在检出远程分支时 会自动进入分离HEAD状态。git clonegit fetch 获取数据 1.从远程仓库下载本地仓库缺失的提交记录；2.更新远程分支指针（比如origin/master）到最新状态 fetch只是把远程的数据下载下来，并不会修改本地的文件git pull 相当于 git fetch; git merge origin/master; 也就是 git fetch 和 git merge 的缩写git push 将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。 不带任何参数时的行为与git的一个名为 push.default 的配置有关。 git pull –rebase 相当于 git fetch; git rebasegit pull; git merge 和上面效果一样，不过上面提交树干净，而下面保留了所有提交历史 master 和 origin/master 的关联关系是由分支的 remote tracking属性决定的，master被设定为跟踪 origin/master 远程跟踪 让任意分支跟踪 origin/master，该分支就会像master分支一样得到隐含的push目的地以及merge的目标。意味着你就可以在分支 totallyNotMaster 上执行 git push两种方法设置这种属性： 1.git checkout -b totallyNotMaster origin/master 创建一个名为 totallyNotMaster的分支，让它跟踪origin/master 2.git branch -u origin/master foo 这样foo就会跟踪origin/master，如果当前就在foo分支上，还可以省略foo push参数git push git push origin master 切到本地仓库的 master 分支，获取所有提交，再到远程仓库 origin 中找到 master 分支，将远程仓库中没有的提交记录都添加上去 通过 place 参数告诉git提交记录来自于 master，要推送到远程仓库中的 master，实际就是要同步的两个仓库的位置 因为已经通过指定参数告诉了git所有它需要的信息，所以它就忽略了我们所检出的分支的属性 place 如果要同时指定源和目的地的的话，只需要用冒号：将二者连起来即可 git push origin : git push origin foo^:master source可以是任何git可以识别的位置！ 如果目的分支不存在，git会在远程仓库中以目的分支的名字创建这个分支 fetch参数push的参数都可以用在fetch上。只不过方向是相反的（push上传，fetch下载）git fetch origin foo git会到远程仓库的foo分支上，然后获取所有本地不存在的提交，放到本地的o/foo上 没有source在push和fetch时可以不指定 source，方法是仅保留冒号和destination的部分，source部分留空git push origin :side 删除远程远程仓库的side分支git fetch origin :bugFix 在本地新建一个 bugFix分支 pull参数pull就是fetch 和 merge的缩写，所以 git pull origin foo 就相当于 git fetch origin foo; git merge o/foo git pull origin bar~1:bugFix 相当于 git fetch origin bar~1:bugFix; git merge bugFix git pull 唯一关注的就是提交最终合并到哪里，也就是fetch提供的 destination参数 | 作者：Dk]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令（一）]]></title>
    <url>%2F2018%2F07%2F19%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用git命令一、git状态工作区域工作区：日常编辑代码的地方本地仓库：保存本地提交记录暂存区：相当于工作区和本地仓库中简的缓存，代表要提交代码的一个工作状态，维护的是一个虚拟的树形结构 文件变化周期添加一个新文件A，A处于 Untracked 状态，通过add将其加至暂存区，A变成 Staged 状态，通过commit提交，A变成 Unmodified 状态，对 Unmodified 状态的文件进行修改，就变成 Unmodified 状态，删除文件，将会使其变成 Untracked 状态 二、基本config123456789查看git配置git config --list编辑git配置git config -e [--global]设置用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[emali]&quot; status12显示工作目录和暂存区的状态git status log1234567891011121314151617查看提交历史git log--oneline 将每个提交放在一行显示git log --oneline--stat，仅显示简要的增改行数统计git log --stat--grep，搜索提交说明中的关键字git log --grep keywords-p 选项展开显示每次提交的内容差异git log -p -- file/path显示所有提交过的用户，按提交次数排序git shortlog -sn diff1234567891011比较暂存区和工作区的差异git diff比较暂存区和上一个commit的差异git diff --cached比较工作区与指定commit-id的差异git diff &lt;commit&gt; [path]显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; 三、本地add1234567891011121314添加文件到暂存区git add [file...]添加指定路径的文件到暂存区git add [path]将所有文件从工作区添加到暂存区，包括修改的、新建的，但不包括删除的git add .将所有文件从工作区添加到暂存区，包括修改的、删除的，但不包括新建的git add -u将所有文件从工作区添加到暂存区，包括修改的、删除的、新建的git add -A commit1234567891011将文件从暂存区提交至本地仓库git commit -m &quot;[your message]&quot;撤销上一次提交git commit --amend将工作区自从上次提交之后的变化 提交至本地仓库git commit -a提交时显示所有diff信息git commit -v branch1234567891011121314151617181920212223242526显示所有本地分支git branch显示所有远程分支git branch -r显示所有分支，包括本地和远程git branch -a新建一个分支，以branch-name命名git branch &lt;branch-name&gt;将old branch分支重命名为new branchgit branch -m &lt;old branch&gt; &lt;new branch&gt;将branch分支强制移动至new place提交位置git branch -f &lt;branch&gt; [new place]新建一个分支branch，并与远程分支remote-branch建立追踪关系git branch --track &lt;branch&gt; &lt;remote-branch&gt;将本地分支branch与远程分支remote-branch建立追踪关系git branch --set-upstream &lt;branch&gt; &lt;remote-branch&gt;删除远程分支git branch -dr [remote/branch] checkout12345678切换至分支branchgit checkout &lt;branch&gt;新建并切换至分支new branchgit checkout -b [new branch]切换至上一个进行操作的分支git checkout - cherry-pick12将指定提交选定，并合进当前分支git cherry-pick &lt;commit 1&gt; ... &lt;commit n&gt; rebase123456以线性关系合并branchgit rebase &lt;upstream&gt; &lt;branch&gt;修改提交历史。startpoint, endpoint 表示一个编辑区间。endpoint如果不指定则默认当前HEAD所指向的commitgit rebase -i &lt;start point&gt; &lt;end point&gt; 四、远程clone12克隆远程仓库git clone remote1234567891011显示所有远程仓库git remote -v显示指定远程仓库git remote show &lt;remote&gt;添加一个远程仓库，并命名为 new namegit remote add &lt;new name&gt; &lt;url&gt;修改远程仓库的地址git remote set-url origin &lt;url&gt; fetch123456下载远程仓库所有变动git fetch从remote仓库的source获取提交记录，放到本地的destination上，如果没有source，将以destination创建一个新分支在本地git fetch &lt;remote&gt; &lt;source&gt;:&lt;destination&gt; pull123456789下载远程仓库的变动并更新至本地git pull从remote仓库的source获取提交记录，放到本地的destination上，最后将destination合并到当前分支上如果没有source，将以destination创建一个新分支在本地，再进行合并git pull &lt;remote&gt; &lt;source&gt;:&lt;destination&gt;以rebase的方式合并提交，相当于执行git fetch; git rebasegit pull --rebase push123456789101112将本地仓库的变动提交至远程仓库git push将本地仓库的source的提交上传至remote远程仓库的destination上如果没有source，将创建一个destination分支git push &lt;remote&gt; &lt;source&gt;:&lt;destination&gt;强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 五、撤销checkout12345将所有暂存区的文件恢复到工作区git checkout .将指定暂存区的文件恢复到工作区git checkout &lt;file&gt; commit12重写上一次commitgit commit --amend merge12抛弃合并git merge --abort reset12345678910111213141516重置暂存区的指定文件git reset &lt;file&gt;重置当前分支的指针为指定提交，重置暂存区，工作区不变commit默认是HEAD，相当于git add的反操作git reset &lt;commit&gt;工作区不改变，但是暂存区会回退到上一次提交之前，HEAD回到上一个提交。git reset --mixed HEAD^工作区和暂存区不改变，HEAD回到上一个提交，即撤销最新的提交。git reset --sort HEAD^撤销最近的提交，工作区和暂存区都会回退到上一次提交的状态HEAD回到上一个提交，即自上一次以来的提交全部丢失。git reset --hard HEAD^ revert12新建一个提交，来撤销指定的提交git revert [commit] stash12345暂时将未提交的变化保存起来git stash恢复之前未提交的变化git stash pop | 作者：Dk]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo写文章]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[正文这里分为两部分，一部分是博客源码，另一部分是操作博客。博客源码存放在github上，相当于博客的砖砖瓦瓦；hexo则是操作工具，用于将这些砖瓦建起来。 博客源码博客源码一般通过git来进行操作管理。每次写博客前记得pull，写完博客发布后别忘了push！ 操作博客安装hexonpm install -g hexo hexo安装完成后，安装依赖包 npm install 这里是hexo的一些常用命令，不需要记，后面用到了再来看就行 12345hexo g # hexo generate 命令的简写，用于生成静态文件hexo s # hexo server 命令的简写，用于启动服务器进行本地预览hexo d # hexo deploy 命令的简写，用于将本地文件发布到github上hexo n # hexo new 命令的简写，用于新建一篇文章hexo clean # 清除缓存文件（db.json）和已生成的静态文件（public） 执行以下命令在本地启动 hexo s 然后通过浏览器访问http://localhost:4000，可以看到博客已经成功运行起来了。这是在本地运行的博客，也就是hexo的本地预览功能。接下来我们来把它挂载到github，让更多人喜欢工作，着迷工作，为工作疯狂。先生成静态文件，执行以下命令 hexo g 接着发布到git上 hexo d 就可以在github上看到我们的博客了，比如我自己的博客地址就是地址点这进入 新建文章运行新建文章的命令 hexo n &quot;文章名字&quot; 可以看到在本地的 ./source/_post/文件夹中已经新生成了一个md文件，hexo中文章是用markdown来写的123456title: my new post #可以改成中文的，如“新文章”date: 2018-06-20 17:16:15 #发表日期，一般不改动categories: blog #文章文类tags: [文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写 插入图片markdown中插入图片的语法 ![Alt text](image path) 对于网上图片，只需要将图片的链接地址写入image path即可； 对于本地图片，需要将图片存入/source/images/文件夹中，再将相对地址/images/图片名称 写入image path，例如 1![Dk](/images/WechatIMG2.jpeg) 由于markdown没有控制图片大小的语法，所以控制图片大小要用 &lt;img&gt; 标签实现，例如 1&lt;img src=&apos;/images/WechatIMG2.jpeg&apos; style=&apos;width: 200px;&apos;/&gt; 发布文章写完之后通过 hexo s 在本地预览效果，满意之后再发布到git上，但是这里要注意，最好在前面再加上hexo clean以清除缓存文件和已生成的静态文件，避免没法正常提交新文件的错误。 hexo clean hexo d hexo g 将文章同步到github上。最后记得git push将改动同步到源码上~ | 作者：Dk]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next搭建个人博客]]></title>
    <url>%2F2018%2F06%2F20%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[这个博客的搭建使用的是静态博客搭建框架hexo，配与next作为博客主题，最后将博客放到github上。省去了申请域名等麻烦的工作，使得搭建博客变得轻松简单。 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown或其他渲染引擎解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Next是hexo下的一个主题，在hexo中，阔以通过切换主题实现博客外观的改变。 安装Hexo依赖 Node.js git 需要电脑上先安装好Node.js和git 然后是安装hexo1npm install -g hexo 安装完毕后，选择一个文件夹，执行hexo init指令生成建立博客所需要的文件1hexo init 接着是安装所需要的依赖1npm install 等待依赖安装的过程可以看一下hexo的一些常用命令，不需要记，后面用到了再来看就行12345hexo g # hexo generate 命令的简写，用于生成静态文件hexo s # hexo server 命令的简写，用于启动服务器进行本地预览hexo d # hexo deploy 命令的简写，用于将本地文件发布到github上hexo n # hexo new 命令的简写，用于新建一篇文章hexo clean # 清除缓存文件（db.json）和已生成的静态文件（public） 在依赖安装完毕后，执行hexo g和hexo s，生成静态文件并启动服务器12hexo ghexo s 可以看到博客已经运行在 localhost:4000 端口上了，打开浏览器访问该地址即可以看到我们的博客已经搭建起来了，在这里可以非常方便地进行本地预览。更多细节可以参考官方文档 主题hexo默认使用的主题是landscape，我这里使用了最近比较流行的next主题。hexo安装主题的过程十分简单，在目录下找到themes文件夹，将要使用的主题文件夹拷入其中，再稍微修改一下配置即可。 安装nextnext有两种安装方式第一种是直接使用 git 克隆到themes文件夹，之后也可以直接通过git pull进行更新12// 定位至themes文件夹目录下git clone https://github.com/iissnan/hexo-theme-next 第二种是下载压缩包，然后解压至themes文件夹next版本发布页面 启用主题把next放入themes文件夹后，找到站点配置文件（根目录下的_config.yml文件），将theme字段的值改为next。如图所示 这时候执行ctrl + C中止本地服务器，然后通过hexo clean清除缓存后，再启动服务器，就可以看到博客的主题已经变成了next了。12hexo cleanhexo s next有很多可以自行配置的设定，如主题设定，语言设定，菜单设定，侧栏设定等等，还有很多诸如评论系统，内容分享，数据统计等强大功能。这里先埋个坑，不多赘述，详情可以前往next官网查看，以后有时间再补充。 部署到githubgithub仓库配置本地预览得满意了，下一步当然就是部署到网上给别人观赏~如果还未拥有github账号，就先去注册申请一个。 新建一个仓库，名字必须是你的github账号名.github.io如图所示，我的账号名是Darkindom，所以我的仓库名相应的就是Darkindom.github.io(这里仓库名前面要和你的账号名一致) 部署本地文件找到站点配置文件（根目录下的_config.yml文件），将其中的deploy改成以下格式（如果没有该字段就新建一个）。 这里如果是第一次使用github，或者更改过账号，可能需要重新配置一下SSH（因为之前使用公司的博客时，用的是另一个github账号，所以切换回来后部署的时候说权限错误，就需要重新配置SSH） 输入以下命令，如果提示要你输入的时候可以先输入回车，如果提示是否要覆盖原先SSH(y/n)输入y1ssh-keygen -t rsa -C &apos;your@email.com&apos; 接着输入以下命令1ssh-agent -s 如果这一步出错，就输入以下命令12eval `ssh-agent -s`ssh-add 接下来就可以把SSH拷贝出来，添加到github账户上了1cat ~/.ssh/id_rsa.pub 将控制台里的那一长串SSH拷贝，打开github账户title随便起一个自己容易辨别的，key里粘贴刚刚复制的SSH 最后测试一下，1ssh -T git@github.com 显示这样就是SSH配置好了 执行hexo g，hexo d部署到github上12hexo ghexo d 如果报了Error Deployer not found: git的错就安装hexo-deployer-git模块1npm install --save hexo-deployer-git 再执行hexo d,完成部署。打开浏览器，输入地址，比如我的就是https://darkindom.github.io/ 大功告成~！ 发布文章关于发布文章的可以看我的另一篇博客《使用hexo写文章》这里再提一点，多人合作的话可以将博客的相关代码保存在另一个git仓库，这样每次发布或者修改文章了，都可以备份到另一个仓库里，然后给权限即可。 参考嘟嘟独立博客 hexo干活系列：（一）hexo+github搭建个人独立博客 | 作者：Dk]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
